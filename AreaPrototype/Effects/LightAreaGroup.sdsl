shader LightAreaGroup<int TMaxLightCount> :
    DirectLightGroupPerDraw,    // Required for "PrepareDirectLightCore()", "PrepareDirectLight()", "ComputeAttenuation()" and other stuff.
    LightArea,  // Required for "AreaLightData".
    // LightAreaAttenuationDefault    // Required for "ComputeAttenuation()"
{
    cbuffer PerDraw.Lighting
    {
        AreaLightData Lights[TMaxLightCount];
    }

    override int GetMaxLightCount()
    {
        return TMaxLightCount;
    }

    /// <summary>
    /// Compute the light color/direction for the specified index within this group
    /// </summary>
    override void PrepareDirectLightCore(int lightIndex)
    {
        // TODO: Workaraound for SPIR-V compiler. Revert later
        AreaLightDataInternal data;
        data.PositionWS = Lights[lightIndex].PositionWS;
        data.DirectionWS = Lights[lightIndex].DirectionWS;
        data.AngleOffsetAndInvSquareRadius = Lights[lightIndex].AngleOffsetAndInvSquareRadius;
        data.Color = Lights[lightIndex].Color;

        ProcessLight(data);
    }

    override float ComputeAttenuation(float3 position, int lightIndex)
    {
        // TODO: Workaraound for SPIR-V compiler. Revert later
        AreaLightDataInternal data;
        data.PositionWS = Lights[lightIndex].PositionWS;
        data.DirectionWS = Lights[lightIndex].DirectionWS;
        data.AngleOffsetAndInvSquareRadius = Lights[lightIndex].AngleOffsetAndInvSquareRadius;

        float3 lightVectorNorm;
        //return ComputeAttenuation(data, position, lightVectorNorm);
        return ComputeAttenuation(data.PositionWS,  // TODO: Revert to the above line as soon as the shader compiler is fixed.
                                    data.AngleOffsetAndInvSquareRadius,
                                    data.DirectionWS,
                                    position, lightVectorNorm);
    }
};